# Enable profiling
zmodload zsh/zprof

# History configuration
HISTFILE="$XDG_DATA_HOME/zsh/history"
HISTSIZE=2000
SAVEHIST=2000
setopt HIST_IGNORE_ALL_DUPS # remove all earlier duplicate lines
setopt APPEND_HISTORY # history appends to existing file
setopt SHARE_HISTORY # import new commands from the history file also in other zsh-session
setopt EXTENDED_HISTORY # save each command's beginning timestamp and the duration to the history file
setopt HIST_REDUCE_BLANKS # trim multiple insgnificant blanks in history
setopt HIST_IGNORE_SPACE # donâ€™t store lines starting with space

# Use emacs keybindings even if our EDITOR is set to vi
bindkey -e

# Make sure that the terminal is in application mode when zle is active, since
# only then values from $terminfo are valid
zmodload zsh/terminfo
if (( ${+terminfo[smkx]} )) && (( ${+terminfo[rmkx]} )); then
    function zle-line-init() {
        echoti smkx
    }
    function zle-line-finish() {
        echoti rmkx
    }
    zle -N zle-line-init
    zle -N zle-line-finish
fi

# Create a zkbd compatible hash
typeset -A key
key[Home]=${terminfo[khome]}
key[End]=${terminfo[kend]}
key[Insert]=${terminfo[kich1]}
key[Delete]=${terminfo[kdch1]}
key[Up]=${terminfo[kcuu1]}
key[Down]=${terminfo[kcud1]}
key[Left]=${terminfo[kcub1]}
key[Right]=${terminfo[kcuf1]}
key[PageUp]=${terminfo[kpp]}
key[PageDown]=${terminfo[knp]}

# Setup keys accordingly
[[ -n "${key[Home]}"     ]]  && bindkey  "${key[Home]}"     beginning-of-line
[[ -n "${key[End]}"      ]]  && bindkey  "${key[End]}"      end-of-line
[[ -n "${key[Insert]}"   ]]  && bindkey  "${key[Insert]}"   overwrite-mode
[[ -n "${key[Delete]}"   ]]  && bindkey  "${key[Delete]}"   delete-char
[[ -n "${key[Left]}"     ]]  && bindkey  "${key[Left]}"     backward-char
[[ -n "${key[Right]}"    ]]  && bindkey  "${key[Right]}"    forward-char
[[ -n "${key[PageUp]}"   ]]  && bindkey  "${key[PageUp]}"   beginning-of-buffer-or-history
[[ -n "${key[PageDown]}" ]]  && bindkey  "${key[PageDown]}" end-of-buffer-or-history

# General configuration
setopt EXTENDED_GLOB
setopt CORRECT_ALL
setopt NO_FLOW_CONTROL # disable stupid annoying keys
setopt MULTIOS # allows multiple input and output redirections
setopt AUTO_CD # if the command is directory and cannot be executed, perfort cd to this directory
setopt CLOBBER
setopt BRACE_CCL
setopt NO_BEEP # do not beep on errors
setopt NO_NOMATCH # try to avoid the 'zsh: no matches found...'
setopt INTERACTIVE_COMMENTS # allow use of comments in interactive code
autoload -U colors && colors  # initialize colors

# Additional completion rules
fpath=($fpath "$ZSHDIR/plugins/completions/src")

# Enable git-extras completions
source "$DOTFILES/tools/git-extras/etc/git-extras-completion.zsh"

# Completion basic
autoload -Uz compinit && compinit -C -d "$XDG_CACHE_HOME/zsh/compdump"
setopt AUTO_PARAM_SLASH
setopt LIST_TYPES
setopt HASH_LIST_ALL # whenever a command completion is attempted, make sure the entire command path is hashed first
setopt COMPLETE_IN_WORD # allow completion from within a word/phrase

# URL magic
autoload -U url-quote-magic
zle -N self-insert url-quote-magic

# MIME aliases
autoload -U zsh-mime-setup
zsh-mime-setup

# Support of bracketed paste
autoload -Uz bracketed-paste-magic
zle -N bracketed-paste bracketed-paste-magic

# Rehash on software upgrade
autoload -U add-zsh-hook
TRAPUSR1() { rehash };
_install_rehash_precmd() {
    if [[ $history[$[HISTCMD-1]] == *(apt-get|aptitude|pip|dpkg|yum|rpm|brew|npm|gem|dnf)* ]]; then
        ps ux | grep "[z]sh" | awk '{print $2}' | xargs kill -USR1
    fi
}
add-zsh-hook precmd _install_rehash_precmd

# Use default zsh prompt symbol
PURE_PROMPT_SYMBOL="%#"

# Indicate that shell is running under Midnight Commander or ranger
if [[ -n "$MC_SID" ]]; then
    _pure_indicate_filemanager() {
        preprompt+=("[mc]")
    }
elif [[ -n "$RANGER_LEVEL" ]]; then
    _pure_indicate_filemanager() {
        preprompt+=("[ranger]")
    }
else
    _pure_indicate_filemanager() {}
fi

# Indicate virtualenv environment
_pure_indicate_virtualenv() {
    if [[ -n "$VIRTUAL_ENV" ]]; then
        preprompt+=("%F{green}venv:${VIRTUAL_ENV:t}%f")
    fi
}

# Enable pure prompt
source "$ZSHDIR/plugins/async/async.zsh"
source "$ZSHDIR/plugins/pure/pure.zsh"

prompt_pure_pieces=(
    _pure_indicate_filemanager
    ${prompt_pure_pieces:0:1}
    _pure_indicate_virtualenv
    ${prompt_pure_pieces:1}
)

# Set MC skin whether we're running under root or not
# Also set skin depending under which terminal we're running
if [[ "$TERM" = "linux" && "$USER" != "root" ]]; then
    export MC_SKIN=modarcon16-defbg
    sudo() { if [[ "$1" = "mc" ]]; then command sudo MC_SKIN=modarcon16root-defbg "$@"; else command sudo "$@"; fi; }
elif [[ "$TERM" = "linux" && "$USER" = "root" ]]; then
    export MC_SKIN=modarcon16root-defbg
elif [[ "$TERM" != "linux" && "$USER" != "root" ]]; then
    export MC_SKIN=modarin256-defbg
    sudo() { if [[ "$1" = "mc" ]]; then command sudo MC_SKIN=modarin256root-defbg "$@"; else command sudo "$@"; fi; }
elif [[ "$TERM" != "linux" && "$USER" = "root" ]]; then
    export MC_SKIN=modarin256root-defbg
fi

# List all directories leading up to a filename; this is useful to see
# if some permissions are blocking access to a file.
lspath () {
    if [[ "$1" = "${1##/}" ]]; then
        pathlist=(/ ${(s:/:)PWD} ${(s:/:)1})
    else
        pathlist=(/ ${(s:/:)1})
    fi
    allpaths=()
    filepath=$pathlist[0]
    shift pathlist
    for i in $pathlist[@]; do
        allpaths=($allpaths[@] $filepath)
        filepath="${filepath%/}/$i"
    done
    allpaths=($allpaths[@] $filepath)
    ls -ld "$allpaths[@]"
}

# Grep from ps output
psg () {
    FST=`echo $1 | sed -e "s/^\(.\).*/\1/"`
    RST=`echo $1 | sed -e "s/^.\(.*\)/\1/"`
    ps aux | grep "[$FST]$RST"
}

# Autoexpand "..." to "../.." and so on
dot () {
    if [[ $LBUFFER = *.. ]]; then
        LBUFFER+=/..
    else
        LBUFFER+=.
    fi
}
autoload -U dot
zle -N dot
bindkey . dot

# Use multithreaded archivers if possible
if (( $+commands[pigz] )); then
    function gzip () { command pigz $@ }
fi

if (( $+commands[pbzip2] )); then
    function bzip2 () { command pbzip2 $@ }
fi

# Print apt history
apt-history () {
    case "$1" in
    install)
        zgrep --no-filename 'install ' $(ls -rt /var/log/dpkg*)
        ;;
    upgrade|remove)
        zgrep --no-filename $1 $(ls -rt /var/log/dpkg*)
        ;;
    rollback)
        zgrep --no-filename upgrade $(ls -rt /var/log/dpkg*) | \
        grep "$2" -A10000000 | \
        grep "$3" -B10000000 | \
        awk '{print $4"="$5}'
        ;;
    *)
        echo "Parameters:"
        echo " install - Lists all packages that have been installed."
        echo " upgrade - Lists all packages that have been upgraded."
        echo " remove - Lists all packages that have been removed."
        echo " rollback - Lists rollback information."
        ;;
    esac
}

# Universal archive unpack
extract () {
    if [[ -f "$1" ]]; then
        case $1 in
            *.tar.bz2) tar xjf $1    ;;
            *.tar.gz)  tar xzf $1    ;;
            *.tar.xz)  tar xJf $1    ;;
            *.bz2)     bunzip2 $1    ;;
            *.rar)     unrar x $1    ;;
            *.gz)      gunzip $1     ;;
            *.tar)     tar xf $1     ;;
            *.tbz2)    tar xjf $1    ;;
            *.tgz)     tar xzf $1    ;;
            *.zip)     unzip $1      ;;
            *.Z)       uncompress $1 ;;
            *.7z)      7z x $1       ;;
            *)         echo "Unknown archive type '$1'" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Universal archive pack
pack () {
    if [[ -n "$1" ]]; then
        case $1 in
            tbz) tar cjvf $2.tar.bz2 $2   ;;
            tgz) tar czvf $2.tar.gz $2    ;;
            txz) tar cJvf $2.tar.xz $2    ;;
            tar) tar cpvf $2.tar $2       ;;
            bz2) bzip2 $2                 ;;
            gz)  gzip -c -9 -n $2 > $2.gz ;;
            zip) zip -r $2.zip $2         ;;
            7z)  7z a $2.7z $2            ;;
            *)   echo "'$1' cannot be packed via pack()" ;;
        esac
    else
        echo "'$1' is not a valid file type"
    fi
}

# Manual page completion
man_glob () {
    local a
    read -cA a
    if [[ $a[2] = [0-9]* ]]; then
        reply=( $^manpath/man$a[2]/$1*$2(N:t:r) )
    elif [[ $a[2] = -s ]]; then
        reply=( $^manpath/man$a[3]/$1*$2(N:t:r) )
    else
        reply=( $^manpath/man*/$1*$2(N:t:r) )
    fi
}
compctl -K man_glob man

# vpaste uploader
vpaste () {
    local uri="http://vpaste.net/"
    local out
    if [ -f "$1" ]; then
        out=`curl -s -F "text=<$1" "$uri?$2"`
    else
        out=`curl -s -F 'text=<-' "$uri?$1"`
    fi
    echo "$out"
    if (( $+commands[xclip] )) && [[ ! -z "$DISPLAY" ]]; then
        echo -n "$out" | xclip -i -selection primary
        echo -n "$out" | xclip -i -selection clipboard
    elif (( $+commands[pbcopy] )); then
        echo -n "$out" | pbcopy
    fi
}

# Make less more friendly
for lpipe in lesspipe lesspipe.sh; do
    if (( $+commands[$lpipe] )); then
        export LESSOPEN="| $lpipe %s"
        export LESSCLOSE="$lpipe %s %s"
        export LESS_ADVANCED_PREPROCESSOR=1
    fi
done
export LESS="-RiwM"

# Color man
export LESS_TERMCAP_mb=$(printf "\e[1;31m")
export LESS_TERMCAP_md=$(printf "\e[1;31m")
export LESS_TERMCAP_me=$(printf "\e[0m")
export LESS_TERMCAP_se=$(printf "\e[0m")
export LESS_TERMCAP_so=$(printf "\e[0;37;102m")
export LESS_TERMCAP_ue=$(printf "\e[0m")
export LESS_TERMCAP_us=$(printf "\e[4;32m")
export _NROFF_U=1

# Enable color support of ls
if (( $+commands[dircolors] )); then
    eval `dircolors "$ZSHDIR/plugins/dircolors-solarized/dircolors.256dark"`
    alias ls="ls --color=auto -F -X"
    alias dir="dir --color=auto"
    alias vdir="vdir --color=auto"
fi

# More colors
if (( $+commands[grc] )); then
    alias colorify="grc -es --colour=auto"
    for command in df dig gcc ifconfig mount mtr netstat ping ps thraceroute; do
        if [[ -f "/usr/local/share/grc/conf.$command" ]] || [[ -f "/usr/share/grc/conf.$command" ]]; then
            alias $command="colorify $command"
        fi
    done
    for command in head tail make ld; do
        alias $command="colorify $command"
    done
fi
if (( $+commands[colordiff] )); then
    alias diff="colordiff -Naur"
fi

# Some handy suffix aliases
alias -s log=less

# Human file sizes
alias df="df -Th"
alias du="du -hc"

# iTerm2 integration
source "$ZSHDIR/plugins/iterm2_integration.zsh"

# Make spark availiable withoud adding it to PATH
alias spark="$DOTFILES/tools/spark/spark"

# Enable mysqltuner without installing it to the PATH
if (( $+commands[perl] )); then
    alias mysqltuner="$DOTFILES/tools/MySQLTuner-perl/mysqltuner.pl"
fi

# Enable mongo-hacker without symlink in home
if [[ -f "$DOTFILES/tools/mongo-hacker/mongo_hacker.js" ]]; then
    mongo() { command mongo "$@" --shell --norc "$DOTFILES/tools/mongo-hacker/mongo_hacker.js"; }
fi

# Enable pyenv, rbenv and nodeenv asynchronously
PATH="$DOTFILES/pyenv/pyenv/bin:$DOTFILES/rbenv/rbenv/bin:$DOTFILES/nodenv/nodenv/bin:$PATH"
env_init_callback() {
    eval "$3" # $3 is stdout
}
async_init
async_start_worker env_init_worker -n
async_register_callback env_init_worker env_init_callback
async_job env_init_worker pyenv init -
async_job env_init_worker rbenv init -
async_job env_init_worker nodenv init -

# Completion tweaks
zstyle ':completion:*' auto-description 'specify: %d'
zstyle ':completion:*' completer _expand _complete _correct _approximate
zstyle ':completion:*' format 'Completing %d'
zstyle ':completion:*' group-name ''
zstyle ':completion:*' menu select
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' list-prompt %SAt %p: Hit TAB for more, or the character to insert%s
zstyle ':completion:*' matcher-list '' 'm:{a-z}={A-Z}' 'm:{a-zA-Z}={A-Za-z}' 'r:|[._-]=* r:|=* l:|=*'
zstyle ':completion:*' select-prompt %SScrolling active: current selection at %p%s
zstyle ':completion:*' verbose true
zstyle ':completion:*' cache-path "$XDG_CACHE_HOME/zsh/compcache"
zstyle ':completion:*:*:kill:*:processes' list-colors "=(#b) #([0-9]#)*=$color[cyan]=$color[red]"
zstyle ':completion:*:kill:*' command 'ps -u $USER -o pid,%cpu,tty,cputime,cmd'
zstyle ':completion::complete:*' use-cache true

# Transfer to root user's Xauth cookies
if [[ `whoami` = root ]] && [[ -n "$SSH_CLIENT" ]] && [[ -n "$SUDO_USER" ]] && [[ -n "$DISPLAY" ]]; then
    display=`echo $DISPLAY | cut -d':' -f 2 | cut -d'.' -f 1`
    cred=`su - $SUDO_USER -c "xauth list" | grep $display`
    echo $cred | xargs -n 3 xauth add
fi

# Allow root to use my DISPLAY (only on linux for now)
if [[ -n "$DISPLAY" ]] && [[ `uname -s` != "Darwin" ]] && (( $+commands[xhost] )); then
    xhost +si:localuser:root 2>&1 1>/dev/null
fi

# Source local zshrc
if [[ -f "$ZSHDIR/zshrc.local" ]]; then
    source "$ZSHDIR/zshrc.local"
fi

# Force path arrays to have unique values only
typeset -U path cdpath fpath manpath

# Enable autoenv plugin
source "$ZSHDIR/plugins/autoenv/autoenv.zsh"

# Autoparis plugin
source "$ZSHDIR/plugins/autopair/autopair.zsh"

# Highlighting plugin
source "$ZSHDIR/plugins/syntax-highlighting/zsh-syntax-highlighting.zsh"
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)

# cdr plugin
ZSH_CDR_DIR="$XDG_CACHE_HOME/zsh"
source "$ZSHDIR/plugins/cdr/cdr.plugin.zsh"

# zaw plugin
source "$ZSHDIR/plugins/zaw/zaw.zsh"
bindkey '^R' zaw-history

# History substring search plugin
source "$ZSHDIR/plugins/history-substring-search/zsh-history-substring-search.zsh"
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='bg=green,fg=white'
bindkey "${key[Up]}"   history-substring-search-up
bindkey "${key[Down]}" history-substring-search-down

# Autosuggestions plugin
source "$ZSHDIR/plugins/autosuggestions/zsh-autosuggestions.zsh"
# Hack to init zsh-asug only once
# https://github.com/zsh-users/zsh-autosuggestions/issues/136#issuecomment-196640897
_zsh_autosuggest_start () {
    add-zsh-hook -d precmd _zsh_autosuggest_start
    _zsh_autosuggest_check_deprecated_config
    _zsh_autosuggest_bind_widgets
}

# Attach to a tmux session, if there's any. Do this only for remote SSH
# sessions, don't mess local tmux sessions.
if (( $+commands[tmux] )) && [[ -z "$TMUX" ]] && pgrep -U `whoami` tmux && [[ -n "$SSH_TTY" ]] && [[ -z "$MC_SID" ]]; then
    tmux attach
fi
