# Enable profiling
zmodload zsh/zprof

# Source configuration files
for conffile in "$ZSHDIR"/rc.d/*; do
    source $conffile
done

# Set MC skin whether we're running under root or not
# Also set skin depending under which terminal we're running
if [[ "$TERM" = "linux" && "$USER" != "root" ]]; then
    export MC_SKIN=modarcon16-defbg
    sudo() { if [[ "$1" = "mc" ]]; then command sudo MC_SKIN=modarcon16root-defbg "$@"; else command sudo "$@"; fi; }
elif [[ "$TERM" = "linux" && "$USER" = "root" ]]; then
    export MC_SKIN=modarcon16root-defbg
elif [[ "$TERM" != "linux" && "$USER" != "root" ]]; then
    export MC_SKIN=modarin256-defbg
    sudo() { if [[ "$1" = "mc" ]]; then command sudo MC_SKIN=modarin256root-defbg "$@"; else command sudo "$@"; fi; }
elif [[ "$TERM" != "linux" && "$USER" = "root" ]]; then
    export MC_SKIN=modarin256root-defbg
fi

# Use multithreaded archivers if possible
if (( $+commands[pigz] )); then
    function gzip () { command pigz $@ }
fi
if (( $+commands[unpigz] )); then
    function gunzip () { command unpigz $@ }
fi
if (( $+commands[pbzip2] )); then
    function bzip2 () { command pbzip2 $@ }
fi
if (( $+commands[pbunzip2] )); then
    function bunzip2 () { command pbunzip2 $@ }
fi

# Universal unarchive function
unarchive () {
    if [[ -f "$1" ]]; then
        case $1 in
            *.tar.bz2) tar xjf $1    ;;
            *.tar.gz)  tar xzf $1    ;;
            *.tar.xz)  tar xJf $1    ;;
            *.bz2)     bunzip2 $1    ;;
            *.rar)     unrar x $1    ;;
            *.gz)      gunzip $1     ;;
            *.tar)     tar xf $1     ;;
            *.tbz2)    tar xjf $1    ;;
            *.tgz)     tar xzf $1    ;;
            *.zip)     unzip $1      ;;
            *.Z)       uncompress $1 ;;
            *.7z)      7z x $1       ;;
            *)         echo "Unknown archive type '$1'" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# Universal archive function
archive () {
    if [[ -n "$1" ]]; then
        case $1 in
            tbz) tar cjvf $2.tar.bz2 $2   ;;
            tgz) tar czvf $2.tar.gz $2    ;;
            txz) tar cJvf $2.tar.xz $2    ;;
            tar) tar cpvf $2.tar $2       ;;
            bz2) bzip2 $2                 ;;
            gz)  gzip -c -9 -n $2 > $2.gz ;;
            zip) zip -r $2.zip $2         ;;
            7z)  7z a $2.7z $2            ;;
            *)   echo "'$1' cannot be packed via pack()" ;;
        esac
    else
        echo "'$1' is not a valid file type"
    fi
}

# Make less more friendly
for lpipe in lesspipe lesspipe.sh; do
    if (( $+commands[$lpipe] )); then
        export LESSOPEN="| $lpipe %s"
        export LESSCLOSE="$lpipe %s %s"
        export LESS_ADVANCED_PREPROCESSOR=1
    fi
done
export LESS="-RiwM"

# iTerm2 integration
source "$ZSHDIR/plugins/iterm2_integration.zsh"

# Make spark availiable withoud adding it to PATH
alias spark="$DOTFILES/tools/spark/spark"

# Enable mysqltuner without installing it to the PATH
if (( $+commands[perl] )); then
    alias mysqltuner="$DOTFILES/tools/MySQLTuner-perl/mysqltuner.pl"
fi

# Enable mongo-hacker without symlink in home
if [[ -f "$DOTFILES/tools/mongo-hacker/mongo_hacker.js" ]]; then
    mongo() { command mongo "$@" --shell --norc "$DOTFILES/tools/mongo-hacker/mongo_hacker.js"; }
fi

# Enable pyenv, rbenv and nodeenv asynchronously
PATH="$DOTFILES/pyenv/pyenv/bin:$DOTFILES/rbenv/rbenv/bin:$DOTFILES/nodenv/nodenv/bin:$PATH"
env_init_callback() {
    eval "$3" # $3 is stdout
}
async_init
async_start_worker env_init_worker -n
async_register_callback env_init_worker env_init_callback
async_job env_init_worker pyenv init -
async_job env_init_worker rbenv init -
async_job env_init_worker nodenv init -

# Transfer to root user's Xauth cookies
if [[ `whoami` = root ]] && [[ -n "$SSH_CLIENT" ]] && [[ -n "$SUDO_USER" ]] && [[ -n "$DISPLAY" ]]; then
    display=`echo $DISPLAY | cut -d':' -f 2 | cut -d'.' -f 1`
    cred=`su - $SUDO_USER -c "xauth list" | grep $display`
    echo $cred | xargs -n 3 xauth add
fi

# Allow root to use my DISPLAY (only on linux for now)
if [[ -n "$DISPLAY" ]] && [[ `uname -s` != "Darwin" ]] && (( $+commands[xhost] )); then
    xhost +si:localuser:root 2>&1 1>/dev/null
fi

# Source local zshrc
if [[ -f "$ZSHDIR/zshrc.local" ]]; then
    source "$ZSHDIR/zshrc.local"
fi

# Force path arrays to have unique values only
typeset -U path cdpath fpath manpath

# Enable autoenv plugin
source "$ZSHDIR/plugins/autoenv/autoenv.zsh"

# Autoparis plugin
source "$ZSHDIR/plugins/autopair/autopair.zsh"

# Highlighting plugin
source "$ZSHDIR/plugins/syntax-highlighting/zsh-syntax-highlighting.zsh"
ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)

# cdr plugin
ZSH_CDR_DIR="$XDG_CACHE_HOME/zsh"
source "$ZSHDIR/plugins/cdr/cdr.plugin.zsh"

# zaw plugin
source "$ZSHDIR/plugins/zaw/zaw.zsh"
bindkey '^R' zaw-history

# History substring search plugin
source "$ZSHDIR/plugins/history-substring-search/zsh-history-substring-search.zsh"
HISTORY_SUBSTRING_SEARCH_HIGHLIGHT_FOUND='bg=green,fg=white'
bindkey "${key[Up]}"   history-substring-search-up
bindkey "${key[Down]}" history-substring-search-down

# Autosuggestions plugin
source "$ZSHDIR/plugins/autosuggestions/zsh-autosuggestions.zsh"
# Hack to init zsh-asug only once
# https://github.com/zsh-users/zsh-autosuggestions/issues/136#issuecomment-196640897
_zsh_autosuggest_start () {
    add-zsh-hook -d precmd _zsh_autosuggest_start
    _zsh_autosuggest_check_deprecated_config
    _zsh_autosuggest_bind_widgets
}

# Attach to a tmux session, if there's any. Do this only for remote SSH
# sessions, don't mess local tmux sessions.
if (( $+commands[tmux] )) && [[ -z "$TMUX" ]] && pgrep -U `whoami` tmux && [[ -n "$SSH_TTY" ]] && [[ -z "$MC_SID" ]]; then
    tmux attach
fi
